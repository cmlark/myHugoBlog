---
title: 十五、调度算法
tags: ["操作系统"]
categories: OS学习笔记
draft: false
date: 2022-04-23T17:11:08+08:00
---

#### 1.先来先服务（FCFS，First Come Firse Serve）

> ##### FCFS
>
> - 算法思想：主要从“公平”的角度考虑（类似于生活中排队买东西）
> - 算法规则：按照作业/进程到达的先后顺序进行服务
> - 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是那个进程先到达就绪队列
> - 是否可抢占？ 非抢占式的算法
> - 优缺点：
>
>   - 优点：公平、算法实现简单
>   - 缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对作业来说用户体验不好。即：FCFS 算法**对长作业有利，对短作业不利**（EG:排队买奶茶）
>
> - 是否会导致**饥饿**（某进程，作业长期得不到服务）：不会（只要进程或作业一直等着总会得到服务）

<!--more-->

例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用**先来先服务**调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、平均带权周转时间。
![LfQXGQ.png](https://s1.ax1x.com/2022/04/23/LfQXGQ.png)

> - **周转时间 = 完成时间 - 到达时间**
>
>   1. P1 = 7 - 0 = 7
>   2. P2 = 11 - 2 = 9
>   3. P3 = 12 - 4 = 8
>   4. P4 = 16 - 5 = 11
>
> - **带权周转时间 = 周转时间 / 运行时间**
>
>   1. P1 = 7 / 7 = 1
>   2. P2 = 9 / 4 = 2.25
>   3. P3 = 8 / 1 = 8
>   4. P4 = 11 / 4 = 2.75
>
> - **等待时间 = 周转时间 - 运行时间**
>
>   1. P1 = 7 - 7 = 0
>   2. P2 = 9 - 7 = 2
>   3. P3 = 8 - 1 = 8
>   4. P4 = 11 - 4 = 7
>
> - **平均周转时间**
>
>   - （7 + 9 + 8 + 11）/ 4 = 8.75
>
> - **平均带权周转时间**
> - （1 + 2.25 + 8 + 2.75）/ 4 = 3.5
>
> - **平均等待时间**
>   - （0 + 5 + 7 + 7）/ 4 = 4.75

注：例题中的进程都是纯计算形的进程，一个进程到达后要么在等待，要么在运行。如果是有计算，又有 I/O 操作的进程，其等待时间就是**周转时间 - 运行时间 - I/O 操作的时间**。对于 P3 进程来说，其带权周转时间的权值为 8，是非常大的权值。带权周转时间表示的是这个进程的运行时间比其等待时间大多少倍的指标。带权周转时间这么大代表这个进程只需要很少的时间就可运行完成但其等待时间又很长，对于 P3 的用户来说体验是很糟糕的。

#### 2.短作业优先（SJF，Shortest Job First）

> ##### SJF
>
> - 算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均平均带权周转时间
> - 算法规则：最短作业/进程得到优先服务（所谓“最短”，是指要求服务时间最短）
> - 用于短作业.进程调度：既可用于作业调度，也可用于进程调度。用于进程调度时成为“短进程优先（SPF，Shortest Process First）”
> - 是否可抢占？：SJF 和 SPF 是**非抢占式**算法，但是**也有抢占式的版本——最短剩余时间优先**算法（SRTF，Shortest Remaining Time Next）
> - 优缺点：
>
>   - 优点：“最短的”平均等待时间，平均周转时间
>   - 缺点：不公平。**对短作业有利，对长作业不利。**可能产生**饥饿现象**。另外，作业/进程的运行时间是由用户提供的，不一定真实，不一定能做到真正的短作业优先。
>
> - 是否会导致饥饿：会。如果有源源不断的短作业/进程进来，可能会使长作业/进程长时间得不到服务，产生**“饥饿”**现象。如果一直得不到服务，则成为**"饿死"**。

例题 1：各进程到达就绪队列的时间、需要的时间如下表所示，使用**非抢占式**的**短作业优先**调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、平均带权周转时间。
![LfUEWV.png](https://s1.ax1x.com/2022/04/23/LfUEWV.png)

> - **周转时间 = 完成时间 - 到达时间**
>
>   1. P1 = 7 - 0 = 7
>   2. P3 = 8 - 4 = 4
>   3. P2 = 12 - 2 = 10
>   4. P4 = 16 - 5 = 11
>
> - **带权周转时间 = 周转时间 / 运行时间**
>
>   1. P1 = 7 / 7 = 1
>   2. P3 = 4 / 1 = 4
>   3. P2 = 10 / 4 = 2.5
>   4. P4 = 11 / 4 = 2.75
>
> - **等待时间 = 周转时间 - 运行时间**
>
>   1. P1 = 7 - 7 = 0
>   2. P3 = 4 - 1 = 3
>   3. P2 = 10 - 4 = 6
>   4. P4 = 11 - 5 = 6
>
> - **平均周转时间**
>
>   - （7 + 4 + 10 + 11）/ 4 = 8
>
> - **平均带权周转时间**
> - （1 + 4 + 2.5 + 2.75）/ 4 = 2.56
>
> - **平均等待时间**
>   - （0 + 3 + 6 + 7）/ 4 = 4

注：严格来说，题目中用于进程调度应该被成为**“短进程优先调度算法（SPF）”**。对比 FCFS 算法的平均等待/周转/带权周转时间都要更低。

例题 2：各进程到达就绪队列的时间、需要的时间如下表所示，使用**抢占式**的**短作业优先**调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、平均带权周转时间。
![LfaacT.png](https://s1.ax1x.com/2022/04/23/LfaacT.png)

> - **周转时间 = 完成时间 - 到达时间**
>
>   1. P1 = 16 - 0 = 16
>   2. P2 = 7 - 2 = 5
>   3. P3 = 5 - 4 = 1
>   4. P4 = 11 - 5 = 6
>
> - **带权周转时间 = 周转时间 / 运行时间**
>
>   1. P1 = 16 / 7 = 2.28
>   2. P2 = 5 / 4 = 1.25
>   3. P3 = 1 / 1 = 1
>   4. P4 = 6 / 4 = 1.5
>
> - **等待时间 = 周转时间 - 运行时间**
>
>   1. P1 = 16 - 7 = 9
>   2. P2 = 5 - 4 = 1
>   3. P3 = 1 - 1 = 0
>   4. P4 = 6 - 4 = 2
>
> - **平均周转时间**
>
>   - （16 + 5 + 1 + 6）/ 4 = 7
>
> - **平均带权周转时间**
> - （2.28 + 1.25 + 1 + 1.5）/ 4 = 1.50
>
> - **平均等待时间**
>   - （9 + 1 + 0 + 2）/ 4 = 3

注：对比非抢占式的短作业优先算法，显然抢占式的这几个指标又要更低。

> **注意**几个小细节：
>
> 1. 如果题目中**未特别说明**，所提到的“短作业/短进程优先算法”**默认**是**非抢占式的**
> 2. 很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”
>
> 严格来说这句话时错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。应该加上一个条件“在**所有进程同时可运行**时，采用 SJF 算法的平均等待时间、平均周转时间最少。”；如果不加上上述前提条件，则应该说“**抢占式的**短作业/短进程优先调度算法（**最短剩余时间优先**，**SRTF**算法）的平均等待时间，平均周转时间最少”
>
> 3. 穗盐染个来说 SJF 的平均等待时间，平均周转时间并不一定最少，但是相比于其他算法（如 FCFS），SJF 依然可以获得较少的平均等待时间、平均周转时间
> 4. 如果选择题中遇到“SJF 算法的平均等待时间，平均周转时间最少”的选项，那最好判断其它选项是不是有很明显的错误，如果没有合适的选项，那应该选择该项。

#### 3.高响应比优先算法（HRRN，Highest Response Ratio Next）

> ##### 对 FCFS 和 SJF 两种算法的思考
>
> - FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。
>
> - SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成界问题
>
> - 能不能设计一个算法，既考虑到各个作业的等待时间，也能兼顾运行时间呢？
>
>   **高响应比优先算法**
>
>   > **（老折中了）**

> ##### HRRN
>
> - 算法思想：要综合考虑作业/进程的等待时间和要求服务时间
>
> - 算法规则：在每次调度时先计算各个作业/进程的**响应比**，选择**响应比最高的**作业/进程为其服务。
>
> $响应比=\frac{等待时间+要求服务时间}{要求服务时间}$，在这里响应比肯定是会>=1 的
>
> - 用于作业/进程调度：既可用于作业调度，也可用于进程调度
> - 是否可抢占？：**非抢占式**的算法，因此只有当前运行的作业/进程主动放弃处理及时，才需要调度，才需要计算响应比
> - 优缺点：
> - 优点：综合考虑了等待时间和运行时间（要求服务时间）。等待时间相同时，要求服务时间短的优先（SJF 的优点）。要求服务时间相同时，等待时间长的优先（FCFS 的优点）。对于长作业来说，随着等待时间越来越久，其相应比也会越来越大，从而避免了长作业饥饿的问题
>
> - 是否会导致饥饿：不会

例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用**高响应比优先**调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、平均带权周转时间。
![Lf565q.png](https://s1.ax1x.com/2022/04/23/Lf565q.png)

> > > > > **上面那里有个错的，(3 + 1) / 1 = 4，不是等于 3😅**

#### 4.知识回顾

![LfIIl8.png](https://s1.ax1x.com/2022/04/23/LfIIl8.png)

> 注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能指标，但是不关心“响应时间”。也不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般是用于**早期的批处理系统**。当然，FCFS 也常结合其他的算法使用，在现在也扮演着很重要的角色。
