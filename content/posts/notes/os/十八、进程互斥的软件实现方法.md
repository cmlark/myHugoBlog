---
title: 十八、进程互斥的软件实现方法
tags: ["操作系统"]
categories: OS学习笔记
draft: false
date: 2022-04-26T21:29:08+08:00
---

#### 1.单标志法

算法思想：两个进程在**访问完临界区后**会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予。**

<!--more-->

```c
int turn = 0; //turn表示当前允许进入临界区的进程号
```

**P0 进程**：

```c
while(turn != 0);    ①//进入区
critical section;  ②//临界区
turn = 1;          ③//退出区
remainder section; ④//剩余区
```

**P1 进程**：

```c
while(turn != 1);    ⑤
critical section;  ⑥
turn = 1;          ⑦
remainder section; ⑧
```

turn 的初始值为 0，即刚开始只允许 0 号进程进入临界区。若 P1 先上处理机运行，则会一直卡在 ⑤。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。

代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，由于 turn 的初始值未改变，P1 依然会卡在 ⑤。只有 P0 在退出区将 turn 改为 1 后，P1 才能进入临界区。

因此，该算法**可以实现“同一时刻最多只允许一个进程访问临界区”**。

turn 表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改 turn 的值。也就是说，对于临界区的访问，一定是按照 P0→P1→P0→P1→......这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。

因此，**单标志法**存在的主要问题是：**违背“空闲让进”原则。**

#### 2.双标志先检查法

算法思想：设置一个布尔型数组 flag[]，数组中的各个元素用来**标记各进程想进入临界区的意愿**，比如“flag[0]=true”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flah[i]设置为 ture，之后开始访问临界区。

```java
bool flag[2]; //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false; //刚开始设置为两个进程不想进入临界区
```

P0 进程：

```java
while(flag[1]);      ①
flag[0] = ture;      ②
critical section;    ③
flag[0] = false;     ④
remainder section;
```

P1 进程：

```java
while(flag[0]);      ⑤  //如果此时P0想进入临界区，P1就一直循环等待
flag[1] = true;      ⑥  //标记为P1进程想要进入临界区
critical section;    ⑦  //访问临界区
flag[1] = false;     ⑧  //访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

若按照 1,5,2,6,3,7 的顺序执行，P0 和 P1 将会同时访问临界区。因此，双标志检查法的**主要问题**是：**违反“忙则等待”原则。**原因在于，**进入区**的“检查”和“上锁”**两个处理不是一气呵成的**，“检查”后，“上锁”前可能发生进程切换。

#### 3.双标志后检查法

算法思想：双标志检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

```java
bool flag[2]; //表示进入临界区意愿的始祖
flag[0] = false;
flag[1] = false; //刚开始设置为两个进程不想进入临界区
```

P0 进程：

```java
flag[0] = ture;      ①
while(flag[1]);      ②
critical section;    ③
flag[0] = false;     ④
remainder section;
```

P1 进程：

```java
flag[1] = true;      ⑤  //如果此时P0想进入临界区，P1就一直循环等待
while(flag[0]);      ⑥  //标记为P1进程想要进入临界区
critical section;    ⑦  //访问临界区
flag[1] = false;     ⑧  //访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

若按照 1,5,2,6....的顺序执行，P0 和 P1 将都无法访问临界区。因此，双标志后检查法虽然**解决了“忙则等待”的问题**的问题，但是又**违背了“空闲让进”和“有限等待”原则**，会因各进程都长期无法访问临界区而**产生“饥饿”**现象。

#### 4.皮特森（Peterson）算法

算法思想：双标志后检查法中，两个进程都想争着进入临界区，但是谁也谁，最后谁都无法进入临界区。Gary L.Peterson 想到了一种方法，如果双方都争着想要进入临界区，那可以让进程尝试“孔融让梨”，主动让对方使用临界区。

```java
bool flag[2]; //表示进入临界区意愿的数组，初始都是false
int turn = 0; //turn表示优先让那个进程进入临界区
```

P0 进程：

```java
flag[0] = ture;               ①
turn = 1;                     ②
while(flag[1] && turn == 1);  ③
critical section;             ④
flag[0] = false;              ⑤
remainder section;
```

P2 进程：

```java
flag[1] = ture;               ⑥ //表示自己想进入临界区
turn = 0;                     ⑦ //可以优先让对方进入临界区
while(flag[0] && turn == 0);  ⑧ //对方想进，且最后一次是自己“让梨”，拿自己就循环等待
critical section;             ⑨
flag[1] = false;              ⑩ //访问完临界区，表示自己已经不想访问临界区了
remainder section;
```

两种双标志检查法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在 Peterson 算法中，两个进程进入区中的各个操作按不同顺序穿插执行会发生什么情况。

> 进入区：
>
> - ① 主动争取
> - ② 主动谦让
> - ③ 检查对方是否也想使用，且最后一次是不是自己说了“客气话”

皮特森算法是用软件方法解决了进程互斥的问题，**遵循了空闲让进，忙则等待，有限等待三个原则**，但是依然**未遵循让权等待**的原则。

![LqWWvR.png](https://s1.ax1x.com/2022/04/27/LqWWvR.png)
