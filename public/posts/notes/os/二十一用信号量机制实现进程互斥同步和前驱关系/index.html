<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>二十一、用信号量机制实现进程互斥、同步和前驱关系 | cmlark's blog</title>
<meta name=keywords content="操作系统"><meta name=description content="1.信号量机制实现进程互斥

分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）
设置互斥信号量 mutex，初始值为 1
在临界区之前执行 P(mutex)
在临界区之后执行 V(mutex)
"><meta name=author content="cmlark"><link rel=canonical href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icons/logo.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icons/favicon-16x16.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icons/favicon-32x32.ico><link rel=apple-touch-icon href=http://localhost:1313/icons/favicon-256x256.ico><link rel=mask-icon href=http://localhost:1313/icons/favicon-32x32.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/"><meta property="og:site_name" content="cmlark's blog"><meta property="og:title" content="二十一、用信号量机制实现进程互斥、同步和前驱关系"><meta property="og:description" content="1.信号量机制实现进程互斥 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区） 设置互斥信号量 mutex，初始值为 1 在临界区之前执行 P(mutex) 在临界区之后执行 V(mutex) "><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-27T19:48:11+08:00"><meta property="article:modified_time" content="2022-04-27T19:48:11+08:00"><meta property="article:tag" content="操作系统"><meta property="og:image" content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:title content="二十一、用信号量机制实现进程互斥、同步和前驱关系"><meta name=twitter:description content="1.信号量机制实现进程互斥

分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）
设置互斥信号量 mutex，初始值为 1
在临界区之前执行 P(mutex)
在临界区之后执行 V(mutex)
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"二十一、用信号量机制实现进程互斥、同步和前驱关系","item":"http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"二十一、用信号量机制实现进程互斥、同步和前驱关系","name":"二十一、用信号量机制实现进程互斥、同步和前驱关系","description":"1.信号量机制实现进程互斥 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区） 设置互斥信号量 mutex，初始值为 1 在临界区之前执行 P(mutex) 在临界区之后执行 V(mutex) ","keywords":["操作系统"],"articleBody":"1.信号量机制实现进程互斥 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区） 设置互斥信号量 mutex，初始值为 1 在临界区之前执行 P(mutex) 在临界区之后执行 V(mutex) //信号量机制实现互斥 semaphore mutex=1; //初始化信号量 P1(){ ... P(mutex); //使用临界区资源前需要加锁 临界代码区段.... V(mutex); //使用临界区资源后需要解锁 ... } P2(){ ... P(mutex); 临界代码区段.... V(mutex); ... } //原理与上节类似 注意：**对不同的临界资源需要设置不同的互斥信号量。P，V 操作必须成对出现。**缺少 P(mutex)就不能保证临界区资源的互斥访问。缺少 V(mutex)会导致资源永不被释放，等待进程永不被唤醒。\n2.信号量机制实现进程同步 进程同步：要让各并发进程按要求有序地推进\n//比如，P1、P2并发的执行，由于存在异步性，因此二者交替推进的次序是不确定的。 //若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是 //在“代码2”之后才会执行。 P1(){ 代码1; 代码2; 代码3; } P2(){ 代码4; 代码5; 代码6; } 用信号量实现进程同步：\n分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码） 设置同步信号量 S，初始值为 0。 在“前操作”之后执行 V(S)； 在“后操作”之前执行 P(S)； //信号量机制实现同步 semaphore S=0; //初始化同步信号量 P1(){ 代码1; 代码2; V(S); 代码3; } P2(){ P(S); 代码4; 代码5; 代码6; } /* 若先执行到V(S)操作，则S++后S=1.之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S--，S的值变回0，P2的进程不会执行block原语，而是继续往下执行代码4. 若先执行到P(S)操作，由于S=0，S--后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。 这样就保证了代码4一定是在代码2之后执行。 */ /* 这里有一点不理解。前面说过了同步信号量S=0时表示没有可用资源，但是如果先执行了P(S)操作，同步信号量S的值会变为-1并阻塞自己，当V(S)被执行后同步信号量S的值变为0并执行wakeup操作唤醒进程P2，若按照前面的陈述那么P2也会认为此时并没有可用资源，因为同步信号量S的值为0，这样P2进程不就饿死了吗？ 不知道是不是我听漏了什么。 */ 3.信号量机制实现前驱关系 进程 P1 中有句代码 S1，P2 中有句代码 S2 一直到 P6。这些代码要求按照如下前驱图所示的顺序来执行。\n每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）\n因此：\n要为每一对前驱关系各设置一个同步变量a，b，c，d，e，f，g 在“前操作”之后对相应的同步变量执行 V 操作 在“后操作”之前对相应的同步变量执行 P 操作 P1(){ ... S1; V(a); V(B); ... } P2(){ ... P(a); S2; V(c); V(d); ... } P3(){ ... P(b); S3; V(g); ... } P4(){ ... P(c); S4; V(e); ... } P5(){ ... P(d); P(f); S5; V(f); ... } P6(){ ... P(e); P(f); P(g); S6; ... } 大概是这个样子：\n4.知识回顾 ","wordCount":"148","inLanguage":"en","image":"http://localhost:1313/%3Clink%20to%20your%20image%3E","datePublished":"2022-04-27T19:48:11+08:00","dateModified":"2022-04-27T19:48:11+08:00","author":{"@type":"Person","name":"cmlark"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/"},"publisher":{"@type":"Organization","name":"cmlark's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/logo.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="cmlark's home page🫣 (Alt + H)"><img src=http://localhost:1313/%F0%9F%AB%A3 alt aria-label=logo height=35>cmlark's home page🫣</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=🏠首页><span>🏠首页</span></a></li><li><a href=http://localhost:1313/archives/ title=📅归档><span>📅归档</span></a></li><li><a href=http://localhost:1313/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=http://localhost:1313/categories/ title=📚分类><span>📚分类</span></a></li><li><a href=http://localhost:1313/tags/ title=🏷标签><span>🏷标签</span></a></li><li><a href=http://localhost:1313/about/ title=📝关于><span>📝关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">二十一、用信号量机制实现进程互斥、同步和前驱关系</h1><div class=post-meta><span title='2022-04-27 19:48:11 +0800 CST'>272711-7-270</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;148 words&nbsp;·&nbsp;cmlark&nbsp;|&nbsp;<a href=mailto:cmlark@qq.com/posts/notes/os/%e4%ba%8c%e5%8d%81%e4%b8%80%e3%80%81%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%9c%ba%e5%88%b6%e5%ae%9e%e7%8e%b0%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5%e3%80%81%e5%90%8c%e6%ad%a5%e5%92%8c%e5%89%8d%e9%a9%b1%e5%85%b3%e7%b3%bb.md rel="noopener noreferrer" target=_blank>文章写错啦😱快来敲打敲打博主~</a></div></header><div class=post-content><h4 id=1信号量机制实现进程互斥>1.信号量机制实现进程互斥<a hidden class=anchor aria-hidden=true href=#1信号量机制实现进程互斥>#</a></h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置<strong>互斥信号量 mutex，初始值为 1</strong></li><li>在临界区之前执行 P(mutex)</li><li>在临界区之后执行 V(mutex)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//信号量机制实现互斥
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>mutex</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=c1>//初始化信号量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>P1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>//使用临界区资源前需要加锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=err>临界代码区段</span><span class=p>....</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span> <span class=c1>//使用临界区资源后需要解锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>P2</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>临界代码区段</span><span class=p>....</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//原理与上节类似
</span></span></span></code></pre></div><p>注意：**对不同的临界资源需要设置不同的互斥信号量。P，V 操作必须成对出现。**缺少 P(mutex)就不能保证临界区资源的互斥访问。缺少 V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><p><img alt=LLm4VH.png loading=lazy src=https://s1.ax1x.com/2022/04/27/LLm4VH.png></p><h4 id=2信号量机制实现进程同步>2.信号量机制实现进程同步<a hidden class=anchor aria-hidden=true href=#2信号量机制实现进程同步>#</a></h4><p>进程同步：要让各并发进程按要求有序地推进</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//比如，P1、P2并发的执行，由于存在异步性，因此二者交替推进的次序是不确定的。
</span></span></span><span class=line><span class=cl><span class=c1>//若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是
</span></span></span><span class=line><span class=cl><span class=c1>//在“代码2”之后才会执行。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>P1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>P2</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>用信号量实现进程同步：</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置<strong>同步信号量 S，初始值为 0</strong>。</li><li><strong>在“前操作”之后执行 V(S)；</strong></li><li><strong>在“后操作”之前执行 P(S)；</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//信号量机制实现同步
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>S</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=c1>//初始化同步信号量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>P1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>P2</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>代码</span><span class=mi>6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>若先执行到V(S)操作，则S++后S=1.之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S--，S的值变回0，P2的进程不会执行block原语，而是继续往下执行代码4.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>若先执行到P(S)操作，由于S=0，S--后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。
</span></span></span><span class=line><span class=cl><span class=cm>这样就保证了代码4一定是在代码2之后执行。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>这里有一点不理解。前面说过了同步信号量S=0时表示没有可用资源，但是如果先执行了P(S)操作，同步信号量S的值会变为-1并阻塞自己，当V(S)被执行后同步信号量S的值变为0并执行wakeup操作唤醒进程P2，若按照前面的陈述那么P2也会认为此时并没有可用资源，因为同步信号量S的值为0，这样P2进程不就饿死了吗？
</span></span></span><span class=line><span class=cl><span class=cm>不知道是不是我听漏了什么。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><h4 id=3信号量机制实现前驱关系>3.信号量机制实现前驱关系<a hidden class=anchor aria-hidden=true href=#3信号量机制实现前驱关系>#</a></h4><p>进程 P1 中有句代码 S1，P2 中有句代码 S2 一直到 P6。这些代码要求按照如下前驱图所示的顺序来执行。</p><p><img alt=LL3Vcn.png loading=lazy src=https://s1.ax1x.com/2022/04/27/LL3Vcn.png></p><p>每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p><p>因此：</p><ol><li>要<strong>为每一对前驱关系各设置一个同步变量</strong>a，b，c，d，e，f，g</li><li><strong>在“前操作”之后对相应的同步变量执行 V 操作</strong></li><li><strong>在“后操作”之前对相应的同步变量执行 P 操作</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>P1</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>S1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>B</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>P2</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>S2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>P3</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>S3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>P4</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>S4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>P5</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>S5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>P6</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>S6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>大概是这个样子：</p><p><img alt=LL8rIU.png loading=lazy src=https://s1.ax1x.com/2022/04/27/LL8rIU.png></p><h4 id=4知识回顾>4.知识回顾<a hidden class=anchor aria-hidden=true href=#4知识回顾>#</a></h4><p><img alt=LLGPzj.png loading=lazy src=https://s1.ax1x.com/2022/04/27/LLGPzj.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/><span class=title>« Prev</span><br><span>二十二、生产者消费者问题</span>
</a><a class=next href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/><span class=title>Next »</span><br><span>二十、信号量机制</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>cmlark's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>