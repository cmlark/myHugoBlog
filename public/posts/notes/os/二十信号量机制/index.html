<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>二十、信号量机制 | cmlark's blog</title>
<meta name=keywords content="操作系统"><meta name=description content="1.信号量机制
进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。
1.在双标志检查法中，进入区的“检查”、‘上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。
2.所有的解决方案都无法实现“让权等待”。
1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法&ndash;信号量机制"><meta name=author content="cmlark"><link rel=canonical href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icons/logo.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icons/favicon-16x16.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icons/favicon-32x32.ico><link rel=apple-touch-icon href=http://localhost:1313/icons/favicon-256x256.ico><link rel=mask-icon href=http://localhost:1313/icons/favicon-32x32.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="cmlark's blog"><meta property="og:title" content="二十、信号量机制"><meta property="og:description" content="1.信号量机制 进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。
1.在双标志检查法中，进入区的“检查”、‘上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。
2.所有的解决方案都无法实现“让权等待”。
1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法–信号量机制"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-27T17:08:57+08:00"><meta property="article:modified_time" content="2022-04-27T17:08:57+08:00"><meta property="article:tag" content="操作系统"><meta property="og:image" content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:title content="二十、信号量机制"><meta name=twitter:description content="1.信号量机制
进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。
1.在双标志检查法中，进入区的“检查”、‘上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。
2.所有的解决方案都无法实现“让权等待”。
1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法&ndash;信号量机制"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"二十、信号量机制","item":"http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"二十、信号量机制","name":"二十、信号量机制","description":"1.信号量机制 进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。\n1.在双标志检查法中，进入区的“检查”、‘上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。\n2.所有的解决方案都无法实现“让权等待”。\n1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法\u0026ndash;信号量机制\n","keywords":["操作系统"],"articleBody":"1.信号量机制 进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。\n1.在双标志检查法中，进入区的“检查”、‘上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。\n2.所有的解决方案都无法实现“让权等待”。\n1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法–信号量机制\n用户可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型信号量），可以用一个信号量来表示系统中的某种资源的数量。\n原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的，软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能“一气呵成”就能避免问题。\n一对原语：wait（s）原语和signal（s）原语，可以把原语理解为我们自己写的函数，函数名称分别为 wait 和 signal，括号里的信号量 s其实就是函数调用时传入的一个参数。wait、signal 原语常简称为 P，V 操作（来自荷兰语 proberen 和 verhogen，意思是“尝试”和“增加”）。因此，wait（s）和 signal（s）可被简写为P（s）和 V（s）。\n2.整形信号量 用一个整数型的变量作为信号量，来表示系统中的某种资源的数量。\n如：某计算机系统中有一台打印机：\nint S = 1; //初始化整形信号量S，表示当前系统中可用的打印机资源数 void wait(int S){ //wait原语，相当于“进入区” while(s \u003c= 0); //如果资源数不够，就一直循环等待 S = S - 1; //如果资源数够，就占用一个资源 } void signal(int S){ //signal原语，相当于\"退出区\" S = S + 1; //使用完资源后，在退出区释放资源 } //如果一个进程P0想要访问打印机，则其操作的伪代码为： ... wait(S); //进入区，申请自愿 使用的印记资源... //临界区，访问资源 signal(S); //退出区，释放资源 ... //如果进程P1在进程P0正在放问打印机时想要访问打印机资源，只能一直执行wait(S)，等待进程P0释放 //临界区资源。 ... wait(S); 访问打印机资源... signal(S); ... 信号量其与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P 操作、V 操作。在 wait 原语中，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。但是如果信号量 S 为 0，则其中的 while 语句会一直检查信号量 S 的占用情况，会一直占用处理机，不满足“让权等待”原则，会发生“忙等”。\n3.记录型信号量（重要） 整形信号量的缺陷是存在“忙等”的问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。\n//信号量的数据结构 typedef struct{ int value; //剩余资源数 struct process *L; //等待队列 } semphore; //某进程需要使用资源时，通过wait原语申请 void wait(semaphore S){ S.value--; if(S.value \u003c 0){ //如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并把它挂到 block(S.L); //信号量S的等待队列（即阻塞队列）中 } } //进程使用完资源后，通过signal原语释放 void signal(semaphore S){ S.value++; if(S.value\u003c=0){ //释放资源后，如果还有别的进程在等待这种资源，则使用wakeup原语唤醒 wakeup(S.L); //等待队列中的一个进程，使该进程从阻塞态变为就绪态。 } } 例：某计算机系统中有两台打印机，则可在初始化信号量 S 时将 S.value 的值设为 2，队列 S.L 设置为空\ntypedef struct{ int value; //剩余资源数为2 struct process *L; //等待队列-→null } //P0进程 ... wait(S); 使用打印机... signal(S); ... //P1进程 ... wait(S); 使用打印机... signal(S); ... //P2进程 ... wait(S); 使用打印机.. signal(S); ... //P3进程 ... wait(S); 使用打印机... signal(S); ... /* 解释：有点啰嗦，能看得懂就行。 cpu首先为p0服务，P0使用wait原语检查剩余资源，系统中剩余打印机资源为2，可以分配给P0，value值减1变为1，P0可以使用打印机。之后cpu又为p1服务，P1使用wait原语检查剩余资源，系统中剩余打印机资源为1，value值减1变为0，可以分配给P1，P1可以使用打印机。再次cpu为P2服务，P2使用wait原语检查剩余打印机资源，系统中剩余打印机资源为0，资源已经暂时全部被占用，value值减1变为-1小于0，P2进程主动执行block原语，P2被挂载到了打印机的等待队列中，P3同理，value值变为-2. value值为0时资源刚好被分配完，为-1时有一个进程在等待，为-2时有两个进程在等待。 当P0使用完成后，会执行signal原语释放打印机，value值加一变为-1，但此时value的值为-1仍然小于0，就说明此时等待队列中不止一个进程在等待打印机资源，进程P0会主动执行wakeup原语唤醒队列中的队头进程P2，P2从阻塞队列中被切换到就绪队列。待P2进程切换至运行态时，就可占用P0释放的打印机资源了。其余后续步骤同理。 */ wait(S)和 signal(S)也可记为 P(S)，V(S)，这对原语用于实现系统资源的申请和释放。\nS.value 的初始值表示系统中某种资源的数目。\n对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.balue–，表示资源数减 1，当 S.value\u003c0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态切换为阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待的原则”，不会出现“忙等”的现象。\n对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数+1，若加一后仍是 S.value\u003c=0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒的进程从阻塞态切换为就绪态）。\n4.知识回顾 ","wordCount":"200","inLanguage":"en","image":"http://localhost:1313/%3Clink%20to%20your%20image%3E","datePublished":"2022-04-27T17:08:57+08:00","dateModified":"2022-04-27T17:08:57+08:00","author":{"@type":"Person","name":"cmlark"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"},"publisher":{"@type":"Organization","name":"cmlark's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/logo.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="cmlark's home page🫣 (Alt + H)"><img src=http://localhost:1313/%F0%9F%AB%A3 alt aria-label=logo height=35>cmlark's home page🫣</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=🏠首页><span>🏠首页</span></a></li><li><a href=http://localhost:1313/archives/ title=📅归档><span>📅归档</span></a></li><li><a href=http://localhost:1313/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=http://localhost:1313/categories/ title=📚分类><span>📚分类</span></a></li><li><a href=http://localhost:1313/tags/ title=🏷标签><span>🏷标签</span></a></li><li><a href=http://localhost:1313/about/ title=📝关于><span>📝关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">二十、信号量机制</h1><div class=post-meta><span title='2022-04-27 17:08:57 +0800 CST'>272757-5-270</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;200 words&nbsp;·&nbsp;cmlark&nbsp;|&nbsp;<a href=mailto:cmlark@qq.com/posts/notes/os/%e4%ba%8c%e5%8d%81%e3%80%81%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%9c%ba%e5%88%b6.md rel="noopener noreferrer" target=_blank>文章写错啦😱快来敲打敲打博主~</a></div></header><div class=post-content><h4 id=1信号量机制>1.信号量机制<a hidden class=anchor aria-hidden=true href=#1信号量机制>#</a></h4><p>进程互斥的四种软件实现方式和进程互斥的三种硬件实现方式都存在一些问题。</p><p>1.在双标志检查法中，<strong>进入区的“检查”、‘上锁”操作无法一气呵成</strong>，从而导致了两个进程有可能同时进入临界区的问题。</p><p>2.所有的解决方案都<strong>无法实现“让权等待”</strong>。</p><p>1965 年，荷兰学者迪杰斯特拉 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法&ndash;<strong>信号量机制</strong></p><p>用户可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便地实现了进程互斥、进程同步。<strong>信号量</strong>其实就是一个变量（可以是一个整数，也可以是更复杂的记录型信号量），可以用一个信号量来<strong>表示系统中的某种资源的数量</strong>。</p><p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断。<strong>原语是由</strong>关中断/开中断指令</strong>实现的，软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能“一气呵成”就能避免问题。</p><p><strong>一对原语</strong>：<strong>wait（s）<strong>原语和</strong>signal（s）<strong>原语，可以把原语理解为我们自己写的函数，函数名称分别为 wait 和 signal，括号里的</strong>信号量 s</strong>其实就是函数调用时传入的一个参数。wait、signal 原语常<strong>简称为 P，V 操作</strong>（来自荷兰语 proberen 和 verhogen，意思是“尝试”和“增加”）。因此，wait（s）和 signal（s）可被简写为<strong>P（s）和 V（s）。</strong></p><h4 id=2整形信号量>2.整形信号量<a hidden class=anchor aria-hidden=true href=#2整形信号量>#</a></h4><p>用一个<strong>整数型的变量</strong>作为信号量，来<strong>表示系统中的某种资源的数量。</strong></p><p>如：某计算机系统中有一台打印机：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=c1>//初始化整形信号量S，表示当前系统中可用的打印机资源数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>void</span><span class=w> </span><span class=nf>wait</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>S</span><span class=p>){</span><span class=w>  </span><span class=c1>//wait原语，相当于“进入区”</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w> </span><span class=c1>//如果资源数不够，就一直循环等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>S</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>     </span><span class=c1>//如果资源数够，就占用一个资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>void</span><span class=w> </span><span class=nf>signal</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>S</span><span class=p>){</span><span class=w> </span><span class=c1>//signal原语，相当于&#34;退出区&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>S</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>      </span><span class=c1>//使用完资源后，在退出区释放资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//如果一个进程P0想要访问打印机，则其操作的伪代码为：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span><span class=w> </span><span class=c1>//进入区，申请自愿</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>使用的印记资源</span><span class=p>...</span><span class=w> </span><span class=c1>//临界区，访问资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span><span class=w>  </span><span class=c1>//退出区，释放资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//如果进程P1在进程P0正在放问打印机时想要访问打印机资源，只能一直执行wait(S)，等待进程P0释放</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//临界区资源。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>访问打印机资源</span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nf>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span></code></pre></div><p>信号量其与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P 操作、V 操作。在 wait 原语中，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。但是如果信号量 S 为 0，则其中的 while 语句会一直检查信号量 S 的占用情况，会一直占用处理机，不满足“让权等待”原则，会发生“忙等”。</p><h4 id=3记录型信号量重要>3.记录型信号量（重要）<a hidden class=anchor aria-hidden=true href=#3记录型信号量重要>#</a></h4><p>整形信号量的缺陷是存在“忙等”的问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//信号量的数据结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>   <span class=c1>//剩余资源数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>process</span> <span class=o>*</span><span class=n>L</span><span class=p>;</span>  <span class=c1>//等待队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>semphore</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//某进程需要使用资源时，通过wait原语申请
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>wait</span><span class=p>(</span><span class=n>semaphore</span> <span class=n>S</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span><span class=p>.</span><span class=n>value</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>S</span><span class=p>.</span><span class=n>value</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>  <span class=c1>//如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并把它挂到
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>block</span><span class=p>(</span><span class=n>S</span><span class=p>.</span><span class=n>L</span><span class=p>);</span>   <span class=c1>//信号量S的等待队列（即阻塞队列）中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//进程使用完资源后，通过signal原语释放
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>signal</span><span class=p>(</span><span class=n>semaphore</span> <span class=n>S</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span><span class=p>.</span><span class=n>value</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>S</span><span class=p>.</span><span class=n>value</span><span class=o>&lt;=</span><span class=mi>0</span><span class=p>){</span>  <span class=c1>//释放资源后，如果还有别的进程在等待这种资源，则使用wakeup原语唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>wakeup</span><span class=p>(</span><span class=n>S</span><span class=p>.</span><span class=n>L</span><span class=p>);</span> <span class=c1>//等待队列中的一个进程，使该进程从阻塞态变为就绪态。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>例：某计算机系统中有两台打印机，则可在初始化信号量 S 时将 S.value 的值设为 2，队列 S.L 设置为空</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>    <span class=c1>//剩余资源数为2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>process</span> <span class=o>*</span><span class=n>L</span><span class=p>;</span>  <span class=c1>//等待队列-→null
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//P0进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>使用打印机</span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//P1进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>使用打印机</span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//P2进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>使用打印机</span><span class=p>..</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//P3进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>使用打印机</span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>解释：有点啰嗦，能看得懂就行。
</span></span></span><span class=line><span class=cl><span class=cm>cpu首先为p0服务，P0使用wait原语检查剩余资源，系统中剩余打印机资源为2，可以分配给P0，value值减1变为1，P0可以使用打印机。之后cpu又为p1服务，P1使用wait原语检查剩余资源，系统中剩余打印机资源为1，value值减1变为0，可以分配给P1，P1可以使用打印机。再次cpu为P2服务，P2使用wait原语检查剩余打印机资源，系统中剩余打印机资源为0，资源已经暂时全部被占用，value值减1变为-1小于0，P2进程主动执行block原语，P2被挂载到了打印机的等待队列中，P3同理，value值变为-2.
</span></span></span><span class=line><span class=cl><span class=cm>value值为0时资源刚好被分配完，为-1时有一个进程在等待，为-2时有两个进程在等待。
</span></span></span><span class=line><span class=cl><span class=cm>当P0使用完成后，会执行signal原语释放打印机，value值加一变为-1，但此时value的值为-1仍然小于0，就说明此时等待队列中不止一个进程在等待打印机资源，进程P0会主动执行wakeup原语唤醒队列中的队头进程P2，P2从阻塞队列中被切换到就绪队列。待P2进程切换至运行态时，就可占用P0释放的打印机资源了。其余后续步骤同理。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>wait(S)和 signal(S)也可记为 P(S)，V(S)，这对原语用于<strong>实现系统资源的申请和释放</strong>。</p><p><strong>S.value 的初始值</strong>表示系统中<strong>某种资源的数目。</strong></p><p>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.balue&ndash;，表示资源数减 1，当 S.value&lt;0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞</strong>（当前运行的进程从<strong>运行态切换为阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待的原则”</strong>，不会出现“忙等”的现象。</p><p>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数+1，若加一后仍是 S.value&lt;=0，表示依然有进程在等待该类资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒的进程从<strong>阻塞态切换为就绪态</strong>）。</p><h4 id=4知识回顾>4.知识回顾<a hidden class=anchor aria-hidden=true href=#4知识回顾>#</a></h4><p><img alt=LLCHn1.png loading=lazy src=https://s1.ax1x.com/2022/04/27/LLCHn1.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/notes/os/%E4%BA%8C%E5%8D%81%E4%B8%80%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%92%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/><span class=title>« Prev</span><br><span>二十一、用信号量机制实现进程互斥、同步和前驱关系</span>
</a><a class=next href=http://localhost:1313/posts/notes/os/%E5%8D%81%E4%B9%9D%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/><span class=title>Next »</span><br><span>十九、进程互斥的硬件实现方法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>cmlark's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>