<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>十六、调度算法（2） | cmlark's blog</title>
<meta name=keywords content="操作系统"><meta name=description content="1.时间片轮转（RR，Round-Robin）

RR


算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应


算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。


用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）


是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到。


优缺点：

优点：公平；响应快，适用于分时操作系统
缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。



是否会导致饥饿：不会


补充：时间片太大或太小会有什么影响？

"><meta name=author content="cmlark"><link rel=canonical href=http://localhost:1313/posts/notes/os/%E5%8D%81%E5%85%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icons/logo.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icons/favicon-16x16.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icons/favicon-32x32.ico><link rel=apple-touch-icon href=http://localhost:1313/icons/favicon-256x256.ico><link rel=mask-icon href=http://localhost:1313/icons/favicon-32x32.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/notes/os/%E5%8D%81%E5%85%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/notes/os/%E5%8D%81%E5%85%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952/"><meta property="og:site_name" content="cmlark's blog"><meta property="og:title" content="十六、调度算法（2）"><meta property="og:description" content="1.时间片轮转（RR，Round-Robin） RR 算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应
算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。
用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）
是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到。
优缺点：
优点：公平；响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。 是否会导致饥饿：不会
补充：时间片太大或太小会有什么影响？"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-25T19:39:43+08:00"><meta property="article:modified_time" content="2022-04-25T19:39:43+08:00"><meta property="article:tag" content="操作系统"><meta property="og:image" content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20to%20your%20image%3E"><meta name=twitter:title content="十六、调度算法（2）"><meta name=twitter:description content="1.时间片轮转（RR，Round-Robin）

RR


算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应


算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。


用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）


是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到。


优缺点：

优点：公平；响应快，适用于分时操作系统
缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。



是否会导致饥饿：不会


补充：时间片太大或太小会有什么影响？

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"十六、调度算法（2）","item":"http://localhost:1313/posts/notes/os/%E5%8D%81%E5%85%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"十六、调度算法（2）","name":"十六、调度算法（2）","description":"1.时间片轮转（RR，Round-Robin） RR 算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应\n算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。\n用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）\n是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到。\n优缺点：\n优点：公平；响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。 是否会导致饥饿：不会\n补充：时间片太大或太小会有什么影响？\n","keywords":["操作系统"],"articleBody":"1.时间片轮转（RR，Round-Robin） RR 算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应\n算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。\n用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）\n是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到。\n优缺点：\n优点：公平；响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。 是否会导致饥饿：不会\n补充：时间片太大或太小会有什么影响？\n例题：例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用时间片轮转调度算法，分析时间片大小分别是 2、5 时的运行情况。\n时间片大小为 2 时的情况：\n时间片大小为 5 时的情况：\n注：时间片轮转算法常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。对比发现，时间片轮转算法在时间片大小为 5 时和上一篇文章中的“先来先服务算法”调度结果类似。如果时间片太大，导致每个进程都能在一个时间片内完成，那么时间片轮转算法就会退化为先来先服务算法，并且会增大进程响应时间。因此时间片不能太大。另外方面，进程切换是有时间代价的（保存，恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。一般来说，设计时间片时要让切换进程的开销比例不超过 1%。\n2.优先级调度算法 优先级调度算法 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。\n算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。\n用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至还会用于 I/O 调度中。\n是否可抢占？：抢占式、非抢占式都有。非抢占式只需在进程主动放弃处级机时进行调度即可，而非抢占式还需在就绪队列变化时，检查是否会发生抢占。\n优缺点：\n优点：用优先级区分任务的紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度。 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿 是否会导致饥饿：会\n例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用非抢占式和抢占式的优先级调度算法，分析进程的运行情况。（注：优先数越大优先级越高）\n非抢占式：\n抢占式：\n注：就绪队列未必只有一个，可以按照不同的优先级组织。另外，可以吧优先级高的进程排在更靠近对头的位置。根据优先级是否可以动态地改变，可将优先级分为静态优先级和动态优先级两种。\n静态优先级：创建进程时确定，之后一直不变。\n动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。\n如何和合理设置各类进程的优先级？通常，系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好 I/O 进程（或称 I/O 繁忙型进程）。I/O 设备可以和 CPU 并行工作。如果优先让 I/O 繁忙型进程优先运行的话，则越有可能让 I/O 设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。与 I/O 型进程相对的是计算型进程（或称 CPU 繁忙型进程）。\n如果采用的是动态优先级，什么时候应该调整？可以从追求公平，提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当的提升其优先级。如果某进程占用处理机运行了很长时间，则可以适当地降低其优先级。如果发现一个进程频繁的进行 I/O 操作，则可以适当的提升其优先级。\n3.思考…….. FCFS 算法的优点是公平；\nSJF 算法的有点是能尽快处理完短作业，平均等待/周转时间等参数很优秀；\n书记安片轮转调度算法可以让各个进程得到及时的响应；\n优先级调度算法可以灵活地调整各种进程被服务的机会；能否对其他算法做个折中权衡，得到一个综合表现优秀平衡的算法呢？\n缝合怪登场！↓↓↓↓↓↓↓↓↓↓↓↓\n4.多级反馈队列调度算法 多级反馈队列 算法思想：对比其他调度算法的折中权衡。\n算法规则：1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；2.新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放入该队列队尾；3.只有第 K 级队列为空时，才会为 k+1 级队头的进程分配时间片\n用于作业/进程调度：用于进程调度\n是否可抢占？：抢占式算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。\n优缺点：\n优点：对各类进程相对公平（FCFS 优点）；每个新到达的进程都可以很快就得到响应（RR 优点）；短进程只用较少的时间就可完成（SPF 优点）；不必实现估计进程的运行时间（避免用户作假）；可以灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队尾，这样 I/O 型进程就可保持较高优先级） 是否会导致饥饿：会\n例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用多级反馈队列调度算法，分析进程的运行情况。\n视频被投诉下架了,可以自己去 b 站搜一下\"王道操作系统\"\n5.知识回顾 注：比起早期的批处理操作系统来说，由于计算机造价大幅度降低，因此之后出现的交互式操作系统（包括分时操作系统，实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法也恰好能较好地满足交互式系统的需求。因此这三种算法更适用于交互式操作系统。（比如 UNIX 使用的就是多级反馈队列调度算法）\n","wordCount":"112","inLanguage":"en","image":"http://localhost:1313/%3Clink%20to%20your%20image%3E","datePublished":"2022-04-25T19:39:43+08:00","dateModified":"2022-04-25T19:39:43+08:00","author":{"@type":"Person","name":"cmlark"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/notes/os/%E5%8D%81%E5%85%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%952/"},"publisher":{"@type":"Organization","name":"cmlark's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/logo.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="cmlark's home page🫣 (Alt + H)"><img src=http://localhost:1313/%F0%9F%AB%A3 alt aria-label=logo height=35>cmlark's home page🫣</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=🏠首页><span>🏠首页</span></a></li><li><a href=http://localhost:1313/archives/ title=📅归档><span>📅归档</span></a></li><li><a href=http://localhost:1313/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=http://localhost:1313/categories/ title=📚分类><span>📚分类</span></a></li><li><a href=http://localhost:1313/tags/ title=🏷标签><span>🏷标签</span></a></li><li><a href=http://localhost:1313/about/ title=📝关于><span>📝关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">十六、调度算法（2）</h1><div class=post-meta><span title='2022-04-25 19:39:43 +0800 CST'>252543-7-250</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;112 words&nbsp;·&nbsp;cmlark&nbsp;|&nbsp;<a href=mailto:cmlark@qq.com/posts/notes/os/%e5%8d%81%e5%85%ad%e3%80%81%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95%ef%bc%882%ef%bc%89.md rel="noopener noreferrer" target=_blank>文章写错啦😱快来敲打敲打博主~</a></div></header><div class=post-content><h4 id=1时间片轮转rrround-robin>1.时间片轮转（RR，Round-Robin）<a hidden class=anchor aria-hidden=true href=#1时间片轮转rrround-robin>#</a></h4><blockquote><h5 id=rr>RR<a hidden class=anchor aria-hidden=true href=#rr>#</a></h5><ul><li><p>算法思想：公平地、轮流地为每个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放回就绪队列尾重新排队。</p></li><li><p>用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理及时间片）</p></li><li><p>是否可抢占？：若进程未在一个时间片内执行完，将被剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知 CPU 时间片已到。</p></li><li><p>优缺点：</p><ul><li>优点：公平；响应快，适用于分时操作系统</li><li>缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。</li></ul></li><li><p>是否会导致饥饿：不会</p></li><li><p>补充：时间片太大或太小会有什么影响？</p></li></ul></blockquote><p>例题：例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用<strong>时间片轮转</strong>调度算法，分析时间片大小分别是 2、5 时的运行情况。</p><p>时间片大小为 2 时的情况：</p><p><img alt=LTMgBj.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTMgBj.png></p><p><img alt=LTMTvF.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTMTvF.png></p><p><img alt=LTQibd.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTQibd.png></p><p>时间片大小为 5 时的情况：</p><p><img alt=LTQZPP.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTQZPP.png></p><p>注：时间片轮转算法常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。对比发现，时间片轮转算法在时间片大小为 5 时和上一篇文章中的“先来先服务算法”调度结果类似。如果<strong>时间片太大</strong>，导致每个进程都能在一个时间片内完成，那么时间片轮转算法就会<strong>退化为先来先服务算法</strong>，并且会<strong>增大进程响应时间</strong>。因此<strong>时间片不能太大</strong>。另外方面，进程切换是有时间代价的（保存，恢复运行环境），因此如果<strong>时间片太小</strong>，会导致<strong>进程切换过于频繁</strong>，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小</strong>。一般来说，设计时间片时要让切换进程的开销比例不超过 1%。</p><h4 id=2优先级调度算法>2.优先级调度算法<a hidden class=anchor aria-hidden=true href=#2优先级调度算法>#</a></h4><blockquote><h5 id=优先级调度算法>优先级调度算法<a hidden class=anchor aria-hidden=true href=#优先级调度算法>#</a></h5><ul><li><p>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p></li><li><p>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。</p></li><li><p>用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至还会用于 I/O 调度中。</p></li><li><p>是否可抢占？：抢占式、非抢占式都有。非抢占式只需在进程主动放弃处级机时进行调度即可，而非抢占式还需在就绪队列变化时，检查是否会发生抢占。</p></li><li><p>优缺点：</p><ul><li>优点：用优先级区分任务的紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度。</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li><li><p>是否会导致饥饿：会</p></li></ul></blockquote><p>例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用<strong>非抢占式</strong>和<strong>抢占式</strong>的<strong>优先级</strong>调度算法，分析进程的运行情况。（注：<strong>优先数越大优先级越高</strong>）</p><p>非抢占式：</p><p><img alt=LTQ1Vs.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTQ1Vs.png></p><p>抢占式：</p><p><img alt=LTQ3an.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTQ3an.png></p><p>注：就绪队列未必只有一个，可以按照不同的优先级组织。另外，可以吧优先级高的进程排在更靠近对头的位置。根据优先级是否可以动态地改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。</p><p>静态优先级：创建进程时确定，之后一直不变。</p><p>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p><blockquote><p>如何和合理设置各类进程的优先级？通常，系统进程优先级<strong>高于</strong>用户进程；前台进程优先级<strong>高于</strong>后台进程；操作系统更<strong>偏好 I/O 进程（或称 I/O 繁忙型进程）</strong>。I/O 设备可以和 CPU 并行工作。如果优先让 I/O 繁忙型进程优先运行的话，则越有可能让 I/O 设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。与 I/O 型进程相对的是<strong>计算型进程（或称 CPU 繁忙型进程）</strong>。</p></blockquote><blockquote><p>如果采用的是动态优先级，什么时候应该调整？可以从追求公平，提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当的提升其优先级。如果某进程占用处理机运行了很长时间，则可以适当地降低其优先级。如果发现一个进程频繁的进行 I/O 操作，则可以适当的提升其优先级。</p></blockquote><h4 id=3思考>3.思考&mldr;&mldr;..<a hidden class=anchor aria-hidden=true href=#3思考>#</a></h4><p>FCFS 算法的优点是公平；</p><p>SJF 算法的有点是能尽快处理完短作业，平均等待/周转时间等参数很优秀；</p><p>书记安片轮转调度算法可以让各个进程得到及时的响应；</p><p>优先级调度算法可以灵活地调整各种进程被服务的机会；能否对其他算法做个折中权衡，得到一个综合表现优秀平衡的算法呢？</p><p>缝合怪登场！↓↓↓↓↓↓↓↓↓↓↓↓</p><h4 id=4多级反馈队列调度算法>4.多级反馈队列调度算法<a hidden class=anchor aria-hidden=true href=#4多级反馈队列调度算法>#</a></h4><blockquote><h5 id=多级反馈队列>多级反馈队列<a hidden class=anchor aria-hidden=true href=#多级反馈队列>#</a></h5><ul><li><p>算法思想：对比其他调度算法的折中权衡。</p></li><li><p>算法规则：1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；2.新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放入该队列队尾；3.只有第 K 级队列为空时，才会为 k+1 级队头的进程分配时间片</p></li><li><p>用于作业/进程调度：用于进程调度</p></li><li><p>是否可抢占？：<strong>抢占式</strong>算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。</p></li><li><p>优缺点：</p><ul><li>优点：对各类进程相对公平（FCFS 优点）；每个新到达的进程都可以很快就得到响应（RR 优点）；短进程只用较少的时间就可完成（SPF 优点）；不必实现估计进程的运行时间（避免用户作假）；可以灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队尾，这样 I/O 型进程就可保持较高优先级）</li></ul></li><li><p>是否会导致饥饿：会</p></li></ul></blockquote><p>例题：各进程到达就绪队列的时间、需要的时间如下表所示，使用<strong>多级反馈队列</strong>调度算法，分析进程的运行情况。</p><p><strong>视频被投诉下架了,可以自己去 b 站搜一下"王道操作系统"</strong></p><h4 id=5知识回顾>5.知识回顾<a hidden class=anchor aria-hidden=true href=#5知识回顾>#</a></h4><p><img alt=LTQYGV.png loading=lazy src=https://s1.ax1x.com/2022/04/25/LTQYGV.png></p><p>注：比起早期的批处理操作系统来说，由于计算机造价大幅度降低，因此之后出现的交互式操作系统（包括分时操作系统，实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法也恰好能较好地满足交互式系统的需求。因此这三种算法更适用于<strong>交互式操作系统</strong>。（比如 UNIX 使用的就是多级反馈队列调度算法）</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/notes/os/%E5%8D%81%E4%B8%83%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/><span class=title>« Prev</span><br><span>十七、进程同步和进程互斥</span>
</a><a class=next href=http://localhost:1313/posts/notes/os/%E5%8D%81%E4%BA%94%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/><span class=title>Next »</span><br><span>十五、调度算法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>cmlark's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>